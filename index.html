<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alpinestalis - Photo Tetris</title>
  <style>
    body { margin: 0; background: #111; color: #fff; text-align: center; }
    canvas { background: #222; display: block; margin: auto; }
  </style>
</head>
<body>
  <h1>Alpinestalis - Photo Tetris</h1>
  <canvas id="game" width="300" height="600"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const blockSize = 30;
    const rows = 20;
    const cols = 10;

    // アップロードした画像をブロックに対応
    const blockImages = {
      I: "I.PNG",
      O: "O.PNG",
      T: "T.PNG",
      L: "L.PNG",
      J: "J.PNG",
      S: "S.PNG",
      Z: "Z.PNG"
    };

    // ブロックの形
    const shapes = {
      I: [[1,1,1,1]],
      O: [[1,1],[1,1]],
      T: [[0,1,0],[1,1,1]],
      L: [[1,0,0],[1,1,1]],
      J: [[0,0,1],[1,1,1]],
      S: [[0,1,1],[1,1,0]],
      Z: [[1,1,0],[0,1,1]]
    };

    let board = Array.from({ length: rows }, () => Array(cols).fill(null));
    let cur;

    // ランダムにブロック生成
    function newPiece() {
      const types = Object.keys(shapes);
      const type = types[Math.floor(Math.random()*types.length)];
      cur = {
        x: Math.floor(cols/2)-1,
        y: 0,
        type,
        shape: shapes[type]
      };
    }

    // ブロック描画
    function drawBlock(x, y, type) {
      if (!type) return;
      let img = new Image();
      img.src = blockImages[type];
      img.onload = () => {
        ctx.drawImage(img, x * blockSize, y * blockSize, blockSize, blockSize);
      };
    }

    // 全体描画
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // ボード
      for (let y=0;y<rows;y++) {
        for (let x=0;x<cols;x++) {
          if (board[y][x]) drawBlock(x,y,board[y][x]);
        }
      }

      // 現在のブロック
      cur.shape.forEach((row,dy)=>{
        row.forEach((val,dx)=>{
          if(val) drawBlock(cur.x+dx,cur.y+dy,cur.type);
        });
      });
    }

    // 衝突判定
    function coll(shape, x, y) {
      return shape.some((row,dy)=>
        row.some((val,dx)=>{
          if (!val) return false;
          let nx = x+dx, ny=y+dy;
          return nx<0||nx>=cols||ny>=rows||board[ny]?.[nx];
        })
      );
    }

    // 固定
    function merge() {
      cur.shape.forEach((row,dy)=>{
        row.forEach((val,dx)=>{
          if(val) board[cur.y+dy][cur.x+dx]=cur.type;
        });
      });
    }

    // ライン消去
    function clearLines() {
      board = board.filter(r => r.some(c=>!c));
      while(board.length<rows) board.unshift(Array(cols).fill(null));
    }

    // 回転
    function rotate() {
      const shape = cur.shape[0].map((_,i)=>cur.shape.map(r=>r[i]).reverse());
      if(!coll(shape,cur.x,cur.y)) cur.shape=shape;
    }

    // 落下
    function drop() {
      if(!coll(cur.shape,cur.x,cur.y+1)){
        cur.y++;
      } else {
        merge();
        clearLines();
        newPiece();
        if(coll(cur.shape,cur.x,cur.y)){
          alert("GAME OVER!");
          board=Array.from({ length: rows }, () => Array(cols).fill(null));
        }
      }
    }

    // 操作
    document.addEventListener("keydown",e=>{
      if(e.key==="ArrowLeft" && !coll(cur.shape,cur.x-1,cur.y)) cur.x--;
      if(e.key==="ArrowRight" && !coll(cur.shape,cur.x+1,cur.y)) cur.x++;
      if(e.key==="ArrowDown") drop();
      if(e.key==="ArrowUp") rotate();
      draw();
    });

    // ゲームループ
    function loop() {
      drop();
      draw();
      setTimeout(loop,500);
    }

    newPiece();
    loop();
  </script>
</body>
</html>
