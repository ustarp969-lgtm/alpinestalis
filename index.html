<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Photo Balance – 6枚バランスゲーム</title>
<style>
  :root { --bg:#0b1020; --fg:#fff; --panel:#121a30; --accent:#32e0a5; }
  html,body{margin:0;height:100%;background:linear-gradient(#1a2953,#0b1020);}
  #hud{position:fixed;top:10px;left:10px;right:10px;display:flex;gap:10px;align-items:center;z-index:5;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;text-shadow:0 2px 6px rgba(0,0,0,.5)}
  #score{font-weight:900}
  #msg{margin-left:auto;opacity:.9}
  #btns{display:flex;gap:8px}
  button{border:none;border-radius:10px;padding:10px 14px;font-weight:800}
  #dropBtn{background:var(--accent);color:#053}
  #retryBtn{background:#24374f;color:#fff}
  #stage{display:block;margin:0 auto;touch-action:none}
  #panel{position:fixed;bottom:10px;left:0;right:0;display:flex;justify-content:center;z-index:5}
  #hint{color:#fff;opacity:.85;font-family:system-ui,-apple-system,sans-serif}
</style>
</head>
<body>
<div id="hud">
  <div id="score">SCORE 0</div>
  <div id="msg">左右にスライド → DROPで落とす</div>
  <div id="btns">
    <button id="dropBtn">DROP</button>
    <button id="retryBtn">Retry</button>
  </div>
</div>
<canvas id="stage" width="420" height="720" aria-label="balance-stage"></canvas>
<div id="panel"><div id="hint">指/マウスで左右移動・タップ/クリックで落下</div></div>

<!-- Matter.js 物理エンジン -->
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
/* ================= 設定（ここだけ見ればOK） ================= */
// 写真ファイル名（リポジトリ直下に置く）
// 既存の I〜S をそのまま使う設定。1.png〜6.png にしたい場合は下の行を差し替え。
const FILES = ["I.PNG","O.PNG","T.PNG","L.PNG","J.PNG","S.PNG"];
// const FILES = ["1.png","2.png","3.png","4.png","5.png","6.png"]; // ←この形で使いたい場合

const CANVAS_W = 420, CANVAS_H = 720;
const BASE_Y   = 560;  // 台の高さ
const BASE_W   = 260, BASE_H = 18;
const MAX_PHOTO_W = 150; // 1枚の最大幅（元画像の比率は維持）
const GRAVITY_Y = 1.0;

/* ================= 前処理：画像読み込み ================= */
function preload(srcs){
  return Promise.all(srcs.map(s=>new Promise(res=>{
    const im=new Image(); im.onload=()=>res({src:s, w:im.naturalWidth, h:im.naturalHeight, im}); im.onerror=()=>res({src:s, w:128, h:128, im:null}); im.src=s+"?v=1";
  })));
}

/* ================== 物理世界の準備 ================== */
const {Engine, Render, Runner, World, Bodies, Body, Events, Composite} = Matter;
const engine = Engine.create({gravity:{x:0, y:GRAVITY_Y}});
const world  = engine.world;

const canvas = document.getElementById('stage');
const render = Render.create({
  canvas,
  engine,
  options:{
    width: CANVAS_W, height: CANVAS_H,
    wireframes: false,
    background: 'transparent',
    pixelRatio: Math.min(window.devicePixelRatio, 2)
  }
});
Render.run(render);
const runner = Runner.create(); Runner.run(runner, engine);

/* === ステージ（台と壁） === */
const ground = Bodies.rectangle(CANVAS_W/2, BASE_Y, BASE_W, BASE_H, {isStatic:true, restitution:0.1,
  render:{fillStyle:"#2ad4a6"}});
const pegL   = Bodies.rectangle(CANVAS_W/2 - BASE_W/2 - 18, BASE_Y-24, 12, 60, {isStatic:true, render:{fillStyle:"#183"}}); // ガード
const pegR   = Bodies.rectangle(CANVAS_W/2 + BASE_W/2 + 18, BASE_Y-24, 12, 60, {isStatic:true, render:{fillStyle:"#183"}});
const wallL  = Bodies.rectangle(-20, CANVAS_H/2, 40, CANVAS_H, {isStatic:true, render:{visible:false}});
const wallR  = Bodies.rectangle(CANVAS_W+20, CANVAS_H/2, 40, CANVAS_H, {isStatic:true, render:{visible:false}});
const floor  = Bodies.rectangle(CANVAS_W/2, CANVAS_H+80, CANVAS_W, 160, {isStatic:true, render:{visible:false}}); // 落下検知用
World.add(world, [ground, pegL, pegR, wallL, wallR, floor]);

/* ================== ゲーム管理 ================== */
let photos = [];       // 読み込んだ画像情報
let queueIndex = 0;    // 次に出す写真
let current = null;    // いま操作中のボディ
let followingX = CANVAS_W/2; // 指/マウス位置
let score = 0;         // 積めた枚数
const scoreEl = document.getElementById('score');
const msgEl   = document.getElementById('msg');

function updateScore(n){ score = n; scoreEl.textContent = "SCORE " + score; }

function makeBodyFromPhoto(p, x, y, isStatic=true){
  // 画像の比率を維持しつつ、最大幅MAX_PHOTO_Wに収める
  const ratio = p.w ? (p.h/p.w) : 1;
  const W = Math.min(MAX_PHOTO_W, p.w || MAX_PHOTO_W);
  const H = W * ratio;
  const body = Bodies.rectangle(x, y, W, H, {
    isStatic,
    restitution: 0.05,
    friction: 0.8,
    frictionStatic: 0.9,
    render: p.im ? { sprite:{ texture:p.src, xScale: W/(p.w||W), yScale: H/(p.h||H) } }
                 : { fillStyle:"#ccc", strokeStyle:"#888", lineWidth:1 }
  });
  return body;
}

function spawnNext(){
  const p = photos[queueIndex % photos.length];
  queueIndex++;
  const x = followingX;
  current = makeBodyFromPhoto(p, x, 80, true); // 最初は静止体→左右に追従
  World.add(world, current);
}

function dropCurrent(){
  if(!current) return;
  Body.setStatic(current, false); // 落とす！
  current = null;
  updateScore(score + 1);
  // 少し待ってから次を生成
  setTimeout(()=>spawnNext(), 600);
}

/* ========== 入力（スマホ/PC共通）========== */
function canvasXFromEvent(e){
  const rect = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  return Math.max(30, Math.min(CANVAS_W-30, (clientX - rect.left) * (CANVAS_W/rect.width)));
}
canvas.addEventListener('pointermove', e=>{
  followingX = canvasXFromEvent(e);
});
canvas.addEventListener('pointerdown', e=>{
  followingX = canvasXFromEvent(e);
  // 画面タップ/クリックでDROP
  dropCurrent();
});
document.getElementById('dropBtn').addEventListener('click', dropCurrent);
document.getElementById('retryBtn').addEventListener('click', ()=>{
  // 全ボディをリセット（台と壁以外を削除）
  const toRemove = Composite.allBodies(world).filter(b=>![ground,pegL,pegR,wallL,wallR,floor].includes(b));
  toRemove.forEach(b=>World.remove(world,b));
  score=0; updateScore(0); queueIndex=0; current=null; spawnNext();
});

/* ====== フォロー制御（静止中の現在ブロックを指に追従させる） ====== */
Events.on(engine, 'beforeUpdate', ()=>{
  if(current && current.isStatic){
    // Xのみ追従（Yは固定）、左右端で台の上に収まるように少し鈍く追従
    const dx = followingX - current.position.x;
    Body.setPosition(current, {x: current.position.x + dx * 0.25, y: current.position.y});
  }
});

/* ====== ゲームオーバー判定 ====== */
Events.on(engine, 'afterUpdate', ()=>{
  // 台より下に落ちたブロックがあればアウト
  const bodies = Composite.allBodies(world);
  const fallen = bodies.find(b => !b.isStatic && b.position.y > CANVAS_H + 40);
  if(fallen){
    msgEl.textContent = "GAME OVER… Retryを押してね";
    // これ以上落とせないように current を無効化
    current = null;
  } else {
    msgEl.textContent = "左右にスライド → DROPで落とす";
  }
});

/* ================== スタートアップ ================== */
preload(FILES).then(list=>{
  photos = list;         // [{src,w,h,im},...]
  Render.lookAt(render, { min:{x:0,y:0}, max:{x:CANVAS_W,y:CANVAS_H} });
  updateScore(0);
  spawnNext();
});
</script>
</body>
</html>
