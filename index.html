<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Balance Safe</title>
<style>html,body{margin:0;height:100%;background:linear-gradient(#dff3ff,#fff0fb)}
#hud{position:fixed;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;
font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
#stage{display:block;margin:0 auto;touch-action:none}
button{border:none;border-radius:10px;padding:8px 14px;font-weight:700}
#drop{background:#ff6394;color:#fff} #retry{background:#75c4ff}</style></head><body>
<div id="hud"><div id="score">SCORE 0</div>
<div><button id="drop">DROP</button> <button id="retry">Retry</button></div></div>
<canvas id="stage" width="420" height="720"></canvas>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
const FILES=["I.PNG","O.PNG","T.PNG","L.PNG","J.PNG","S.PNG"]; // なければ色で描画
const MAX_W=70, W=420,H=720; const GY=0.95;
const {Engine,Render,Runner,World,Bodies,Body,Events,Composite}=Matter;
const eng=Engine.create({gravity:{x:0,y:GY}}), world=eng.world;
const cvs=document.getElementById('stage');
const ren=Render.create({canvas:cvs,engine:eng,options:{width:W,height:H,wireframes:false,background:'transparent'}});
Render.run(ren); Runner.run(Runner.create(),eng);
// 必ず見える台（矩形）
const platform=Bodies.rectangle(W/2,600,260,18,{isStatic:true,render:{fillStyle:"#222"}});
const wallL=Bodies.rectangle(-20,H/2,40,H,{isStatic:true,render:{visible:false}});
const wallR=Bodies.rectangle(W+20,H/2,40,H,{isStatic:true,render:{visible:false}});
World.add(world,[platform,wallL,wallR]);
// 画像プリロード
function preload(list){return Promise.all(list.map(s=>new Promise(r=>{const im=new Image();
im.onload=()=>r({src:s,w:im.naturalWidth,h:im.naturalHeight,im}); im.onerror=()=>r({src:s,w:100,h:100,im:null}); im.src=s+"?v=1";})))}
let imgs=[],qi=0,cur=null,follow=W/2,score=0,over=false;
function make(p,x,y,st=true){const r=p.w? p.h/p.w:1, w=Math.min(MAX_W,p.w||MAX_W), h=w*r;
return Bodies.rectangle(x,y,w,h,{isStatic:st,restitution:.08,friction:.7,
render:p.im?{sprite:{texture:p.src,xScale:w/(p.w||w),yScale:h/(p.h||h)}}:{fillStyle:"#ffc6ef"}})}
function spawn(){ if(over) return; const p=imgs[qi++%imgs.length]; cur=make(p,follow,80,true); World.add(world,cur); }
function drop(){ if(!cur||over) return; Body.setStatic(cur,false); cur=null; document.getElementById('score').textContent="SCORE "+(++score); setTimeout(spawn,500); }
cvs.addEventListener('pointermove',e=>{const r=cvs.getBoundingClientRect(); follow=Math.max(30,Math.min(W-30,(e.clientX-r.left)*(W/r.width)));});
cvs.addEventListener('pointerdown',drop); document.getElementById('drop').onclick=drop;
document.getElementById('retry').onclick=()=>{Composite.allBodies(world).forEach(b=>{if(![platform,wallL,wallR].includes(b))World.remove(world,b)}); qi=0;score=0;over=false;document.getElementById('score').textContent="SCORE 0";spawn()};
Events.on(eng,'beforeUpdate',()=>{ if(cur&&cur.isStatic){ Body.setPosition(cur,{x:cur.position.x+(follow-cur.position.x)*0.25,y:cur.position.y}); }});
Events.on(eng,'afterUpdate',()=>{ const fell=Composite.allBodies(world).find(b=>!b.isStatic&&b.position.y>680); if(fell){over=true;} });
preload(FILES).then(list=>{imgs=list; spawn();});
</script></body></html>
